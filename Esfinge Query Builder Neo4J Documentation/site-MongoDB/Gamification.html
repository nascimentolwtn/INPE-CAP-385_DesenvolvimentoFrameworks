<!DOCTYPE HTML>
<html>
<head>
    <meta charset="utf-8">
    <title>Esfinge Gamification</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="Html5TemplatesDreamweaver.com">
    <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW"> <!-- Remove this Robots Meta Tag, to allow indexing of site -->

    <link href="scripts/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="scripts/bootstrap/css/bootstrap-responsive.min.css" rel="stylesheet">
    <link href="scripts/icons/general/stylesheets/general_foundicons.css" media="screen" rel="stylesheet" type="text/css" />  
    <link href="scripts/icons/social/stylesheets/social_foundicons.css" media="screen" rel="stylesheet" type="text/css" />
    <link rel="stylesheet" href="scripts/fontawesome/css/font-awesome.min.css">
    <link href="scripts/carousel/style.css" rel="stylesheet" type="text/css" />
    <link href="scripts/camera/css/camera.css" rel="stylesheet" type="text/css" />

    <link href="http://fonts.googleapis.com/css?family=Syncopate" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Abel" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Source+Sans+Pro" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Pontano+Sans" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Oxygen" rel="stylesheet" type="text/css">

    <link href="styles/custom.css" rel="stylesheet" type="text/css" />
</head>
<body id="pageBody">

<div id="divBoxed" class="container">

    <div class="transparent-bg" style="position: absolute;top: 0;left: 0;width: 100%;height: 100%;z-index: -1;zoom: 1;"></div>

    <div class="divPanel notop nobottom">
            <div class="row-fluid">
                <div class="span12">

                    <div id="divLogo" class="pull-left">
                        <a href="index.html" id="Esfinge Framework"><img src="images/logo.png" alt="Site Name" title="Site Name" /></a>
                        <div style="clear:both"></div>
                        <a href="index.html" id="divTagLine"<></a>
                    </div>

                    <div id="divMenuRight" class="pull-right">
                    <div class="navbar">
                        <button type="button" class="btn btn-navbar-highlight btn-large btn-primary" data-toggle="collapse" data-target=".nav-collapse">
                            NAVEGAÇÃO <span class="icon-chevron-down icon-white"></span>
                        </button>
                        <div class="nav-collapse collapse">
                            <ul class="nav nav-pills ddmenu">
                            <li><a href="index.html">Home</a></li>
                            <li><a href="Oprojeto.html">O Projeto</a></li>
                            <li class="dropdown">
                            <a class="dropdown-toggle">Download<b class="caret"></b></a>
                            <ul class="dropdown-menu">
                            <li><a href="http://sourceforge.net/projects/esfinge/files/Esfinge2/QueryBuilder%201.4/">Esfinge Query Builder</a></li>
                            <li><a href="http://sourceforge.net/projects/esfinge/files/Esfinge2/Comparison%201.0/">Esfinge Comparasion</a></li>
                            <li><a href="http://sourceforge.net/projects/esfinge/files/Esfinge2/Guardian%201.0/">Esfinge Guardian</a></li>
                            <li><a href="http://sourceforge.net/projects/esfinge/files/Esfinge2/SystemGlue%201.0/">Esfinge SystemGlue</a></li>
                            <li><a href="http://sourceforge.net/projects/esfinge/files/Esfinge2/AOM%20Role%20Mapper%200.1/">Esfinge AOM Role Mapper</a></li>
                            </ul>
                            </li>
                            <li class="dropdown">
                            <a class="dropdown-toggle">Documentação<b class="caret"></b></a>
                            <ul class="dropdown-menu">
                            <li><a href="Query Builder.html">Esfinge Query Builder</a></li>
                            <li><a href="Comparasion.html">Esfinge Comparasion</a></li>
                            <li><a href="Guardian.html">Esfinge Guardian</a></li>
                            <li><a href="SystemGlue.html">Esfinge SystemGlue</a></li>
                            <li><a href="AOM.html">Esfinge AOM Role Mapper</a></li>
                            <li><a href="Gamification.html">Esfinge Gamification</a></li>
                            </ul>
                            </li>
                            <li><a href="http://frameworkesfinge.wix.com/esfinge">Blog</a></li>
                            <li><a href="Contato.html">Contato</a></li>
                            </ul>
                            </div>
                    </div>
                    </div>

                </div>
            </div>

                    <p>&nbsp;</p>
                    <h2>Esfinge Gamification</h2>
                     <td><a href="https://github.com/EsfingeFramework/gamification"><div align="right"><p><img src="images/codigofonte.png"></div></td></a>
                    <hr>
                    <div class="wp-spoiler wpui-light"><h3 class="ui-collapsible-header fade-true slide-true open-false"><span class="ui-icon"></span>Visão geral</h3></div>
<hr>
<div style="text-align: justify;"><p>O Esfinge Gamification é um framework baseado em metadados aplicável aos sistemas que necessitam de uma lógica <em>gamification</em>, independentemente do seu domínio. O principal objetivo do framework é dissociar  as preocupações de <em>gamification</em> da aplicação, permitindo que os desenvolvedores se concentrem na lógica da aplicação, acrescentando apenas informação sobre como a <em>gamification</em> devem trabalhar em cada funcionalidade invocada. O framework intercepta estas invocações e executa a lógica <em>gamification</em> apropriada. Fornece pontos de extensão que permitem a introdução de comportamentos <em>gamification</em> específicos da aplicação.</p>
  
<p>O Esfinge Gamification   define vários tipos de <em>conquistas</em> e diferentes implementações para armazenar  informações <em>gamification</em> sobre os usuários. Para registrar como a <em>gamification</em> deve ser manuseada na aplicação, o framework usa <em><strong>anotações</strong></em> que devem ser adicionadas aos métodos de negócio nas classes de aplicação. O framework proposto pode ser facilmente integrado em qualquer aplicação Java, sendo responsável por registrar as <em>conquistas</em> do usuário sem depender de qualquer informação relacionada com o domínio específico da aplicação. Ele fornece  também uma API que pode ser acessada diretamente pelo aplicativo para recuperar e mostrar informações relacionadas com as <em>conquistas</em> do usuário, tais como sua <em>pontuação</em> ou sua <em>posição no ranking</em>.</p></div>

<p><strong style="font-size: 15px; color: #e05f03;">Instanciando o framework</strong></p>
<div style="text-align: justify;">O objetivo desta subseção é apresentar as medidas necessárias para instanciar Esfinge Gamification em um aplicativo.</div>
<div style="text-align: justify;"> O primeiro passo é configurar a classe que deve ser usada para armazenar a informação <em>gamification</em> e o atual usuário. O código a seguir apresenta um exemplo de como isso deve ser feito. A instância configurada deve estender a classe abstrata <code>Game</code>. O framework fornece algumas implementações que armazenam essas informações em arquivos, em memória e em um banco de dados; no entanto, o aplicativo pode criar sua própria implementação para ele. Este exemplo é configurado chamando o método <code>setGame()</code> no <code>GameInvoker.</code></div></br>

<pre>
//configure game<br>Game g = new GameMemoryStorage();<br>GameInvoker.getInstance().setGame(g);
<br>//current user<br>UserStorage.setUserID(&quot;spider&quot;);
</pre>

<div style="text-align: justify;"><p>Outra configuração importante apresentada no código anterior é o usuário atual. O  método <code>setUserID()</code>na classe <code>UserStorage</code> deve ser chamado para configurar o usuário e para ser usado pelo framework na   <em>thread </em>atual. Assim, todos os métodos invocados na <em>thread</em> atual que desencadeiam a lógica <em>gamification</em> usará este usuário como    uma referência. O parâmetro deve ser qualquer identificação do usuário, que será utilizado para fins de armazenamento e de recuperação. Por exemplo, para criar uma instância do framework em uma aplicação web, um filtro web deve ser criado para configurar o usuário atual em cada solicitação recebida.
</p><div style="text-align: justify;"><p>O próximo  passo é adicionar as <em><strong>anotações</strong></em> <em>gamification</em> adequadas sobre as interfaces dos  aplicativos. Os métodos escolhidos para ser anotadas deve representar a ação  no domínio do aplicativo que deve acionar a lógica <em>gamification</em>. O código a  seguir ilustra o uso da <em><strong>anotação </strong></em><code>@PointsToUser</code>. Com base na configuração,  quando uma implementação do método <code>answerQuestion() </code>é invocado, o framework <em>gamification</em> deve adicionar 10 pontos de resposta para o usuário atual. É  importante ressaltar que existem outras <em><strong>anotações</strong></em> fornecidos pela estrutura, e  também fornece um ponto de extensão que permite a criação de <em><strong>anotações</strong></em> personalizadas. </p></div>
</div>
<pre>public interface Questionnaire {<br>	@PointsToUser(name = &quot;ANSWER&quot;, quantity = 10)<br>	public void answerQuestion(String answer);<br>}</pre>
<div style="text-align: justify;">O passo  final para instanciar o framework é permitir a <SPAN id="D_DEF">interceptação</SPAN> dos métodos de invocação da aplicação. Esfinge Gamification funciona com <em><strong>proxies </strong></em>dinâmicos que encapsulam  as classes da aplicação para introduzir a invocação da lógica <em>gamification</em> com  base nas <em><strong>anotações</strong></em> configuradas. Para criar o <strong><em>proxy</em></strong>, o método <code>createProxy()</code>da classe<code> GameProxy </code>deve ser invocado. Ele recebe uma instância da implementação e  retorna um <strong><em>proxy</em></strong> dinâmico que implementa todas as suas interfaces. O código a  seguir apresenta um exemplo de como isso deve ser feito. É aconselhável encapsular essa lógica de criação de uma classe <em>factory</em>.</div></p></br>

<pre>Questionnaire q = (Questionnaire) GameProxy.createProxy(new<br>  QuestionnaireImpl());</pre>

<div style="text-align: justify;">
<p>Para finalizar, o aplicativo pode usar a API do framework para acessar diretamente os dados <em>gamification</em>. Esta API está disponível através da implementação do classe <code>Game,</code> que pode ser recuperada usando o comando <code>GameInvoker.getInstance().GetGame()</code>. Eses pontos, quando o aplicativo precisar de informações <em>gamification</em> , deve ser a única lógica de negócios que tem acesso direto ao framework.</p>
<div style="text-align: justify;">
<p><strong style="font-size: 15px; color: #e05f03;">Estrutura interna</strong></p>

</div>
<p>Sobre como  implementar os modelos...</p>

<div style="text-align: justify;">
<p><strong style="font-size: 15px; color: #e05f03;">Tipos de conquistas</strong></p>
<div style="text-align: justify;">     
<p>O framework usa um sistema de recompensa no qual  o usuário pode receber um certo tipo de <em>conquista</em> quando uma tarefa é  executada ou realizada no aplicativo. Conforme ilustrado na figura abaixo, no Esfinge Gamification, quatro tipos de  <em>conquista</em>s podem ser encontradas:<em> Ponto, Classificação, Recompensa e Troféu</em>. A interface <code>Achievement</code> também pode ser estendida para  incluir outros tipos de recompensas.</p>
</div>

<p>&nbsp;</p>
		<center>
			<img src="images/EsfingeFigura1.png" width="554" height="419">
		</center>
	
<div style="text-align: justify;">
  <p>O tipo de  <em>Ponto</em> representa um <em>affordance</em> que contém uma medida de número discreto, tais como  pontos ou moedas, que podem ser utilizados para alcançar outras <em>conquista</em>s, ou  para usar dentro do próprio sistema. O mesmo sistema pode ter diferentes tipos  de <em>Ponto</em>s. O tipo <em>Ranking</em> representa um nível de usuário escalar e é descrito  por dois atributos, um <em>nome</em> e um <em>nível</em>. Ele pode ser usado para explicar a  melhoria  de alguma tarefa do usuário ou representar o seu status. Por exemplo,  quando uma tarefa é concluída com êxito um certo número de vezes, o usuário  pode subir um <em>nível</em> naquela habilidade. Isso incentiva o usuário a explorar as  tarefas a serem realizadas e também melhorar o trabalho realizado.</p>
  <p>A  <em>conquista</em> de <em>Recompensa</em> representa algo que o usuário ganha e pode gastar. As  suas características são um <em>nome</em> e uma variável booleano que indica se a  <em>Recompensa já foi usada</em>. O usuário mantém esta <em>Recompensa</em> até que ele decida  usá-la para algum propósito. Por exemplo, se a <em>Recompensa</em> é um cupom de  desconto, ele estará disponível até que o usuário o utilize. O tipo <em>Troféu</em>, que  é semelhante ao de distintivos, como no mundo real, descreve um prêmio recebido  apenas uma vez. O usuário pode receber um <em>Troféu</em> para a realização de uma  tarefa, mas ele não vai ganhar de novo se ele repetir a mesma tarefa.</p>
  <p>Novos tipos de realizações podem ser adicionados ao implementar a interface <code>Achievement</code>. Esta interface possui métodos para definir o que deve ser feito quando uma nova <em>conquista</em> desse tipo é adicionado para um usuário. A seguir estão os métodos definidos por esta interface:</p>

<ul>
<div style="text-align: justify;"><li><code>public String getName()</code>: retorna o nome de identificação da <em>conquista</em>.</li></div>

<div style="text-align: justify;"><li><code>public void addAchievement(Object user, Achievement a)</code>: usado para atribuir um usuário a uma <em>conquista</em>, tando no caso de inserção como no caso de upgrade.</li></div>

<div style="text-align: justify;">
  <li><code>public void removeAchievement(Object user, Achievement a)</code>: usado para remover uma <em>conquista</em> de um determinado usuário. Dependendo do tipo de <em>conquista</em>, a operação pode ser efetuada uma supressão ou de atualização.</li></div>

</ul>
<br>

</div>

<div style="text-align: justify;">
<p><strong style="font-size: 15px; color: #e05f03;">Gerenciamento de conquistas</strong></p>
<div style="text-align: justify;">
 
<p>Além da  interface <code>Achievement</code> e suas implementações, o framework define um componente cuja  função é armazenar as <em>conquista</em>s. A classe abstrata <code>Game</code> encapsula a mecânica  <em>gamification</em> de armazenamento. Ele define métodos abstratos que devem ser  implementados a fim de dar as ações apropriadas para atribuir ou remover  <em>conquista</em>s do usuário. Atualmente, três subclasses de jogo estão disponíveis:  <code>GameMemoryStorage</code>, que mantém dados armazenados apenas na memória;  <code>GameFileStorage</code>, que armazena os resultados em um arquivo de propriedades; e<code> GameDatabaseStorage</code>, que salva os <em>affordances</em> em um banco de dados SQL. </p>
<p>Os  métodos relativos à armazenagem de <em>conquista</em>s são:</p>
<ul>
  <div style="text-align: justify;">
  <li><code>public abstract void insertAchievement (Object user, the Achievement)</code>: define o que deve ser feito para atribuir uma nova <em>conquista</em> para um usuário.</li>
</div>
<div style="text-align: justify;">
  <li><code>public abstract void deleteAchievement (Object user, the Achievement)</code>: define o que deve ser feito para eliminar uma <em>conquista</em> de um usuário.</li>
</div>
<div style="text-align: justify;">
  <li><code>public abstract void updateAchievement (Object user, the Achievement)</code>: define o que deve ser feito para mudar uma <em>conquista</em> que o usuário possui.</li>
</div>
<div style="text-align: justify;">
  <li><code>public abstract Achievement getAchievement (Object user, String achievName)</code>: define a forma de recuperar dados de <em>conquista</em> de um usuário.</li>
</div>
<div style="text-align: justify;">
  <li><code>public abstract Map &lt;String, Achievement&gt; getAchievements (Object user)</code>: configura como recuperar todas as <em>conquista</em>s de um usuário.</li>
</div>
</ul>
</div>
<p>As subclasses concretas do jogo devem gerenciar as <em>conquista</em>s sem o uso de seus tipos concreto. Isto é importante para permitir a extensão dos tipos de <em>conquista</em>.</p>
<p>  As implementações da classe <code>Game</code> pode fornecer métodos mais específicos para consultar as informações <em>gamification</em>. Por exemplo, pode haver métodos para recuperar as <em>classificações</em> ou para localizar a <em>posição do usuário</em>. Em versões futuras esses recursos devem ser padronizados na API do framework.</p>

<div style="text-align: justify;">
<p><strong style="font-size: 15px; color: #e05f03;">Metadados <em>gamification</em></strong></p>

<div style="text-align: justify;">
<p>Além da criação e armazenamento de <em>conquista</em>s, as operações que adicionam ou removem as <em>conquista</em>s podem ser configuradas através de <em><strong>anotações</strong></em> para serem acionadas com base na invocação de métodos de interface do aplicativo. A lista de <em><strong>anotações</strong></em> fornecidos pelo framework Esfinge Gamification para a configuração das <em>conquista</em>s  é descrita abaixo.</p></div></br>

<div>
<table width="83%" border="1" cellpadding="0" cellspacing="0" style="width: 80%;">
<tbody>
<tr>
<td width="25%"><strong>Anotações</strong></td>
<td width="75%"><strong>Descrição geral</strong></td>
</tr>
<tr>
<td><code>@PointsToUser, @RankingsToUser,<br>
  @RewardsToUser, @TrophiesToUses</code></td>
<td>Estas anotações permitem que o incremento de uma implementação de <em>conquista</em>s para o usuário atual.<br></td>
</tr>

<tr>
<td><code>@RemoveRankings, @RemovePoints, <br>@RemoveReward, @RemoveTrophy</code></td>
<td>Estas anotações permitem a eliminação de uma implementação de <em>conquista</em>s de um determinado usuário.<br></td>
</tr>

<tr>
<td><code>@PointToParam<br>
</code></td>
<td> Esta anotação permite o incremento de <em>Pontos</em> para outro usuário, ou seja, a ação do usuário logado no sistema gera pontos para outro usuário.</td>
</tr>

</tbody>
</table>
</div>
</br> 
 
<div style="text-align: justify;">
<p>  É importante ressaltar que a <em><strong>anotação </strong></em><code>@PointsToParam</code>  pode fazer uso de <em><strong>anotação</strong></em> <code>@Named</code> para rotular o parâmetro que contém o <em>ID do usuário</em> que deve receber os <em>pontos</em>. Abaixo, exemplifica-se como estas <em><strong>anotações</strong></em> devem ser configuradas em uma interface do aplicativo.</p></div>

<pre>public interface ITestAnnotations {<br>	@PointsToUser(name = &quot;GOLD&quot;, quantity = 1000)<br>	public void doSomething();
<br>	@RewardsToUser(Name = &quot;lunch&quot;, used = false)<br>	public void doSomethingRemarcable();
<br>	@RemovePoints(name = &quot;GOLD&quot;, quantity = 500)<br>	public void doBadThing();
<br>	@RemoveReward(Name = &quot;lunch&quot;, used = true)<br>	public void useReward();
<br>	@PointsToParam (name = &quot;SILVER&quot;, quantity = 100, param = &quot;owner&quot;)<br>	public void niceComment(String comment, @Named(&quot;owner&quot;) String owner);
<br>	@PointsToParam (name = &quot;SILVER&quot;, quantity = 300, param = &quot;comment&quot;<br>		prop =&quot;user.login&quot;)<br>	public void niceComment(@Named(&quot;comment&quot;) Comment c);
}</pre>

<div style="text-align: justify;">
Nos dois primeiros métodos há um exemplo de <em><strong>anotações</strong></em> que dá <em>conquista</em>s para o usuário atual, e nos próximos dois há exemplos de <em><strong>anotações</strong></em> para  desencadear a remoção deles. Os últimos dois métodos apresentam exemplos de uma <em><strong>anotação</strong></em> que dá pontos para um usuário que está sendo referenciado em um <code>param</code>. O  atributo da <em><strong>anotação</strong></em> <code>param</code>  refere-se ao nome de atributo, marcado pela anotação <code>@Named</code>, que contém o <em>ID de usuário</em>. O  atributo <code>prop</code> pode ser utilizado para configurar o estabelecimento de parâmetros que contém a informação. </div>
<div style="text-align: justify;">É importante ressaltar que não houve uma preocupação em criar um grande número de <em><strong>anotações</strong></em> para cobrir todos os requisitos possíveis. No entanto, em vez do framework, existe um mecanismo que será apresentado na próxima subseção que permite a extensão das suas <em><strong>anotações</strong></em>. As anotações fornecidas pretendem exemplificar que tipo de configurações que pode ser realizada.</div></br>

<p><strong style="font-size: 15px; color: #e05f03;">Pontos de extensão</strong></p>

<div style="text-align: justify;">
  <p>O framework Esfinge Gamification tem dois <em>ponto de extensão</em> internos: um que configura a  persistência e outro que permite a adição de novos tipos de <em>conquista</em>s. A  persistência pode ser estendido para ser compatível com o que é usado na  aplicação. Este <em>ponto de extensão</em> pode ser ampliado através da criação de uma nova  subclasse da classe abstrata <code>Game</code> e configurado na classe<code> GameInvoker.</code> Para  criar novos tipos de <em>conquista</em>s, o primeiro passo é criar uma nova  implementação da interface <code>Achievement</code>, que define as regras para a adição e  remoção de tais <em>conquista</em>s. O mecanismo de persistência deve também estar  pronto para lidar com essas <em>conquista</em>s e devem ser criadas <em><strong>anotações</strong></em> para  desencadear ações para a sua gestão. Alguns detalhes para esses <em>ponto de extensão</em> foram apresentadas nas seções anteriores.</p></div>
<div style="text-align: justify;">A criação  de novas <em><strong>anotações</strong></em> pode ser visto como o <em>ponto de extensão</em> quadro principal.  Para cada nova <em><strong>anotação</strong></em> deve ter uma classe que sabe como interpretar as  informações e executar a ação que deve ser acionada quando um método com ela é  invocado. O código a seguir apresenta a <em><strong>anotação</strong></em> <code>@PointsToUser</code> para ilustrar como esta extensão funciona. Todas as <em><strong>anotações</strong></em> <em>gamification</em> deve ter uma <em><strong>anotação</strong></em> <code>@GamificationProcessor</code> que configura a classe do  processador relacionado.</div></br>
<pre>
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@GamificationProcessor(PointsToUserProcessor.class)

public @interface PointsToUser {
	int quantity();
	String name();
}</pre>

<div style="text-align: justify;">
  <p>A classe  configurada na <em><strong>anotação</strong></em> deve implementar a interface <code>AchievementProcessor</code>. Essa  interface define o método <code>receiveAnnotation()</code>, que é responsável por  interpretar a <em><strong>anotação</strong></em>, recuperando informações de seus atributos específicos.  O  método <code>process()</code>é responsável por executar a ação na lógica <em>gamification</em> relacionada com a <em><strong>anotação</strong></em>. Nesta classe específica que dá pontos para o  usuário atual.</p>
</div>


<pre>
public class PointsToUserProcessor implements AchievementProcessor {
	private int quantity;
	private String name;

	@Override
	public void receiveAnnotation(Annotation an) {
	PointsToUser ptu = (PointsToUser) an;
	quantity = ptu.quantity();
	name = ptu.name();
}

@Override
public void process(Game game, Object encapsulated, Method method,
			Object[] args) {
		Object currentUser = UserStorage.getUserID();
		Point p = new Point(quantity, name);
		game.addAchievement(user, p);
	}
}</pre>


<div style="text-align: justify;">
  <p>É  importante destacar que este mecanismo pode ser usado para adicionar lógica  específica do aplicativo diferente para o framework. Por exemplo, uma <em><strong>anotação</strong></em> pode configurar pontos para o usuário atual, a alguém relacionado com a ação do  usuário, e até mesmo para grupo ou uma equipe em que o usuário participa. No  entanto, usando esta abordagem, as ações relacionadas com a <em>gamification</em> são  dissociados das classes de aplicação, estando relacionadas apenas por seus  metadados.</p>
</div>

</div>
</div>

             		<p>&nbsp;</p>
                    <p>&nbsp;</p>
                    <p>&nbsp;</p>

                    <div align="center"><p><strong style="font-size: 20px;color: #000000">Apoio</strong></p></div>
                    <div align="center"><td><a href="http://www.inpe.br/"><img class="alignleft size-full wp-image-192" title="bt_leiamais" src="images/inpe.png" border="0" alt="" width="123" height="34" /></a></td></div>


                    <div id="divFooter" style="height:50px;margin-top:40px;padding:30px">
                    <div class="row-fluid">
                    <div align="center"><p><img src="images/logo2.png" alt="" width="611" height="104" /></p></div>
                    <div align="center"><p><strong style="font-size: 10px; color: #000000">Todos os direitos reservados</strong></p></div>
                    </div>
                    
                    </div>
                </div>


<script src="scripts/jquery.min.js" type="text/javascript"></script> 
<script src="scripts/bootstrap/js/bootstrap.min.js" type="text/javascript"></script>
<script src="scripts/default.js" type="text/javascript"></script>

<script src="scripts/carousel/jquery.carouFredSel-6.2.0-packed.js" type="text/javascript"></script><script type="text/javascript">$('#list_photos').carouFredSel({ responsive: true, width: '100%', scroll: 2, items: {width: 320,visible: {min: 2, max: 6}} });</script><script src="scripts/camera/scripts/camera.min.js" type="text/javascript"></script>
<script src="scripts/easing/jquery.easing.1.3.js" type="text/javascript"></script>
<script type="text/javascript">function startCamera() {$('#camera_wrap').camera({ fx: 'scrollLeft', time: 2000, loader: 'none', playPause: false, navigation: true, height: '35%', pagination: true });}$(function(){startCamera()});</script>

            </body>
</html>