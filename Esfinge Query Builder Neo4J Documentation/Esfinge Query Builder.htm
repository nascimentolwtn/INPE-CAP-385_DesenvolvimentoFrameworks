<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <title>Esfinge Query Builder</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="Html5TemplatesDreamweaver.com">

    <link href="Esfinge%20Query%20Builder_files/bootstrap.css" rel="stylesheet">
    <link href="Esfinge%20Query%20Builder_files/bootstrap-responsive.css" rel="stylesheet">

    <link href="Esfinge%20Query%20Builder_files/general_foundicons.css" media="screen" rel="stylesheet" type="text/css">  
    <link href="Esfinge%20Query%20Builder_files/social_foundicons.css" media="screen" rel="stylesheet" type="text/css">
   
    <link rel="stylesheet" href="Esfinge%20Query%20Builder_files/font-awesome.css">

    <link href="Esfinge%20Query%20Builder_files/css_003.css" rel="stylesheet" type="text/css">
    <link href="Esfinge%20Query%20Builder_files/css_004.css" rel="stylesheet" type="text/css">
    <link href="Esfinge%20Query%20Builder_files/css_006.css" rel="stylesheet" type="text/css">
    <link href="Esfinge%20Query%20Builder_files/css_002.css" rel="stylesheet" type="text/css">
    <link href="Esfinge%20Query%20Builder_files/css_005.css" rel="stylesheet" type="text/css">
    <link href="Esfinge%20Query%20Builder_files/css.css" rel="stylesheet" type="text/css">

    <link href="Esfinge%20Query%20Builder_files/custom.css" rel="stylesheet" type="text/css">
</head>
<body id="pageBody">

<div id="divBoxed" class="container">

    <div class="transparent-bg" style="position: absolute;top: 0;left: 0;width: 100%;height: 100%;z-index: -1;zoom: 1;"></div>

    <div class="divPanel notop nobottom">
            <div class="row-fluid">
                <div class="span12">

                    <div id="divLogo" class="pull-left">
                        <a href="http://esfinge.sourceforge.net/index.html" id="Esfinge Framework"><img src="Esfinge%20Query%20Builder_files/logo.png" alt="Site Name" title="Site Name"></a>
                        <div style="clear:both"></div>
                        <a href="http://esfinge.sourceforge.net/index.html" id="divTagLine" <=""></a>
                    </div>

                    <div id="divMenuRight" class="pull-right">
                    <div class="navbar">
                        <button type="button" class="btn btn-navbar-highlight btn-large btn-primary" data-toggle="collapse" data-target=".nav-collapse">
                            NAVEGAÇÃO <span class="icon-chevron-down icon-white"></span>
                        </button>
                        <div class="nav-collapse collapse">
                            <ul class="nav nav-pills ddmenu">
                            <li><a href="http://esfinge.sourceforge.net/index.html">Home</a></li>
                            <li><a href="http://esfinge.sourceforge.net/Oprojeto.html">O Projeto</a></li>
                            <li class="dropdown">
                            <a class="dropdown-toggle">Download<b class="caret"></b></a>
                            <ul class="dropdown-menu">
                            <li><a href="http://sourceforge.net/projects/esfinge/files/Esfinge2/QueryBuilder%201.4/">Esfinge Query Builder</a></li>
                            <li><a href="http://sourceforge.net/projects/esfinge/files/Esfinge2/Comparison%201.0/">Esfinge Comparasion</a></li>
                            <li><a href="http://sourceforge.net/projects/esfinge/files/Esfinge2/Guardian%201.0/">Esfinge Guardian</a></li>
                            <li><a href="http://sourceforge.net/projects/esfinge/files/Esfinge2/SystemGlue%201.0/">Esfinge SystemGlue</a></li>
                            <li><a href="http://sourceforge.net/projects/esfinge/files/Esfinge2/AOM%20Role%20Mapper%200.1/">Esfinge AOM Role Mapper</a></li>
                            </ul>
                            </li>
                            <li class="dropdown">
                            <a class="dropdown-toggle">Documentação<b class="caret"></b></a>
                            <ul class="dropdown-menu">
                            <li><a href="http://esfinge.sourceforge.net/Query%20Builder.html">Esfinge Query Builder</a></li>
                            <li><a href="http://esfinge.sourceforge.net/Comparasion.html">Esfinge Comparasion</a></li>
                            <li><a href="http://esfinge.sourceforge.net/Guardian.html">Esfinge Guardian</a></li>
                            <li><a href="http://esfinge.sourceforge.net/SystemGlue.html">Esfinge SystemGlue</a></li>
                            <li><a href="http://esfinge.sourceforge.net/AOM.html">Esfinge AOM Role Mapper</a></li>
                            <li><a href="http://esfinge.sourceforge.net/Gamification.html">Esfinge Gamification</a></li>
                            </ul>
                            </li>
                            <li><a href="http://frameworkesfinge.wix.com/esfinge">Blog</a></li>
                            <li><a href="http://esfinge.sourceforge.net/Contato.html">Contato</a></li>
                            </ul>
                            </div>
                    </div>
                    </div>

                </div>
            </div>

            <div class="row-fluid">
                <div class="span12">
                    <div id="contentInnerSeparator"></div>
                </div>
            </div>
    </div>

    <div class="contentArea">

        <div class="divPanel notop page-content">
            <div class="row-fluid">
            <!--Edit Main Content Area here-->
                <div class="span12" id="divMain">

                    <h2>Esfinge Query Builder - Persistência simples e rápida</h2>
                    <a href="http://esfinge.sourceforge.net/pdf/Artigo%20Esfinge%20Query%20Builder.pdf"><div align="right"><p><img src="Esfinge%20Query%20Builder_files/aja.png"></p></div></a>
                     <a href="https://github.com/EsfingeFramework/querybuilder_plugin"><div align="right"><p><img src="Esfinge%20Query%20Builder_files/codigofonte.png"></p></div></a>
                    <hr>
<div class="wp-spoiler wpui-light"><h3 class="ui-collapsible-header fade-true slide-true open-false"><span class="ui-icon"></span>Funcionalidades Básicas do Query Builder</h3></div>
<hr>
<div style="text-align: justify;">O Esfinge Query Builder oferece uma 
solução para a criação de uma camada de persistência de forma simples e 
rápida. Através da filosofia “para um bom framework, o nome do método 
basta”, o Query Builder utiliza os nomes dos métodos de uma interface 
para inferir as consultas que precisam ser executadas na base de dados.</div>
<p>&nbsp;</p>
<p><strong style="font-size: 15px; color: #e05f03;">Query Builder em 1 minuto</strong></p>
<div style="text-align: justify;">Essa seção apresenta uma visão geral rápida de como o Esfinge Query Builder é utilizado na prática.</div>
<div style="text-align: justify;">O primeiro passo é a definição de uma 
interface com os nomes do métodos referentes as consultas que precisam 
ser feitas. Opcionalmente, quando se deseja que sejam disponibilizadas 
operações CRUD, pode-se estender a interface Repository. Veja o exemplo 
da interface abaixo criada para a classe Person.</div>
<pre>public interface PersonDAO extends Repository&lt;Person&gt;{
    public List&lt;Person&gt; getPersonByLastName(String lastname);
    public List&lt;Person&gt; getPersonByAddressCity(String city);
    public List&lt;Person&gt; getPersonByAgeGreater(Integer age);
}</pre>
<div style="text-align: justify;">O segundo passo é criar a interface e 
utilizar. Só isso? É só isso mesmo! A idéia do Query Builder é realmente
 deixar a criação da interface de persistência muito simples. Veja 
abaixo como criar a instância da classe que realmente implementa essa 
interface:</div>
<pre>PersonDAO dao = QueryBuilder.create(PersonDAO.class);</pre>
<p><strong style="font-size: 15px; color: #e05f03;">Como funciona?</strong></p>
<div style="text-align: justify;">Os nomes dos métodos são interpretados
 pelo Query Builder que gera em tempo de execução uma consulta que é 
executada no banco de dados e tem seu resultado retornado. O método 
getPersonByLastName(), por exemplo, retorna instâncias da classe Person 
filtrando pela propriedade lastName. O método getPersonByAddressCity() 
faz a consulta filtrando pela propriedade city da propriedade address, 
que é também uma classe persistente. Finalmente, o método 
getPersonByAgeGreater() irá retornar pessoas com idade maior do que a 
recebida como parâmetro.</div>
<p>Achou fácil? Saiba mais sobre os detalhes e as funcionalidades do QueryBuilder nas seções seguintes.</p>
<p><strong style="font-size: 15px; color: #e05f03;">Configurando o Query Builder</strong></p>
<div style="text-align: justify;"><span style="font-family: Verdana,Arial,Helvetica,sans-serif;">O
 Query Builder foi feito para poder funcionar independente do mecanismo 
de persistência utilizado pela aplicação. Por enquanto, está disponível 
apenas uma versão para JPA 1, que trabalha em cima da geração de 
consultas em JPAQL. As classes principais do framework são divididas em 2
 arquivos JAR: <strong>esfinge_querybuilder_core_1_X.jar</strong> e <strong>esfinge_querybuilder_jpa1_1_X.jar</strong>. O primeiro contém as funcionalidades gerais do framework e o segundo as classes específicas para o JPA. O arquivo <strong>esfinge_querybuilder_jpalocal1_1_X.jar</strong>
 só deve ser incluído caso as transações do entity manager do JPA sejam 
gerenciadas localmente. Caso as transações sejam controladas por um 
container EJB atarvés do JTA ou por um framework como o Spring, esse 
arquivo não deve ser incluído.</span></div>
<p>Além disso ainda são necessárias outros JAR básicos para o acesso ao 
banco de dados, como o driver de conexão e a implementação JPA.</p>
<div style="text-align: justify;">Além disso, é necessário criar uma 
classe, que implementa a interface 
org.esfinge.querybuilder.jpa1.EntityManagerProvider, responsável por 
retornar as instâncias de EntityManager e EntityManagerFactory 
utilizadas pela aplicação. No caso de uma aplicação que utilizasse o JPA
 independente de um servidor de aplicações, essa classe seria como o 
exemplo exibido abaixo. No caso do uso de um container, por exemplo, a 
implementação deveria recuperar as instâncias do contexto JNDI.</div>
<pre>public class TestEntityManagerProvider implements EntityManagerProvider {
    @Override
    public EntityManager getEntityManager() {
        return getEntityManagerFactory().createEntityManager();
    }

    @Override
    public EntityManagerFactory getEntityManagerFactory() {
        return Persistence.createEntityManagerFactory("database_test");
    }
}</pre>
<p>Para configurar essa nova classe criada, é preciso criar um arquivo 
chamado org.esfinge.querybuilder.jpa1.EntityManagerProvider no diretório
 META-INF/services de algum dos arquivos JAR da aplicação. Esse arquivo 
deve conter apenas o nome completo da classe criada.</p>
<p><strong style="font-size: 15px; color: #e05f03;">Repositório</strong></p>
<div style="text-align: justify;">Apesar de não ser uma de suas 
funcionalidades principais, o Query Builder implementa as 
funcionalidades básicas de CRUD. Para que isso possa ser utilizado basta
 que a interface criada implemente a interface 
org.esfinge.querybuilder.Repository. É importante que ao implementar 
essa interface seja definido qual a classe persistente que está sendo 
utilizada, como por exemplo Repository&lt;Person&gt;.</div>
<p>Abaixo seguem os métodos disponibilizados por essa interface com as respectivas descrições:</p>
<div>
<table style="width: 80%;" border="1" cellpadding="0" cellspacing="0">
<tbody>
<tr>
<td width="35%"><strong>Método</strong></td>
<td width="65%"><strong>Descrição</strong></td>
</tr>
<tr>
<td>E save(E obj)</td>
<td>Grava no banco de dados o objeto passado como parêmetro. O objeto é inserido caso não exista ou atualizado caso já exista.</td>
</tr>
<tr>
<td>void delete(Object id)</td>
<td>O método exclui da base de dados a entidade cujo id foi passado como parâmetro.</td>
</tr>
<tr>
<td>List&lt;E&gt; list()</td>
<td>Retorna uma lista com todas as entidades do banco de dados.</td>
</tr>
<tr>
<td>E getById(Object id)</td>
<td>Retorna uma instância de acordo com o id passado como parâmetro.</td>
</tr>
<tr>
<td>List&lt;E&gt; queryByExample(E obj)</td>
<td>Faz uma query que faz a busca de acordo com as propriedades populadas do objeto.</td>
</tr>
</tbody>
</table>
</div>
<p>&nbsp;</p>
<p><strong style="font-size: 15px; color: #e05f03;">Nomeandos os Métodos</strong></p>
<div style="text-align: justify;">Os nomes dos métodos da interface são 
utilizados para a geração das consultas e por isso é muito importante 
saber nomea-los corretamente. Abaixo seguem algumas regras para a 
criação dos métodos:</div>
<ul>
<div style="text-align: justify;"><li><span style="font-family: Verdana,Arial,Helvetica,sans-serif;">Os métodos devem começar com <em><strong>get</strong></em> e serem seguidos do nome da entidade. O nome utilizado deve ser o mesmo utilizado pelo JPA. Exemplo: </span><span style="font-family: Verdana,Arial,Helvetica,sans-serif;">List&lt;Person&gt; getPerson()</span></li></div>
<div style="text-align: justify;"><li>Para passar parâmetros para a consulta, o nome da entidade deve ser seguido por <em><strong>by</strong></em>
 e por nomes de propriedades da classe. O parâmetro deve ser do mesmo 
tipo da propriedade. Exemplo: Person getPersonByName(String name) e 
Person getPersonByLastName(String name)</li></div>
<div style="text-align: justify;"><li>Os métodos podem retornar uma 
instância da entidade ou uma lista de instâncias da entidade , como os 
dois exemplos anteriores apresentados.</li></div>
<div style="text-align: justify;"><li>O parâmetro passado pode navegar 
entre as dependências da classe e acessar propriedades delas. Exemplo: 
List&lt;Person&gt; getPersonByAddressCity(String city) , que filtraria a
 propriedade city na propriedade address.</li></div>
<div style="text-align: justify;"><li>Para passar mais de um parâmetro 
pode-se utilizar and ou or entre as propriedades. Os parâmetros serão 
considerados na mesma ordem definida no nome. Exemplo: Person 
getPersonByNameAndLastName(String name, String lastname) e 
List&lt;Person&gt; getPersonByNameOrLastName(String name, String 
lastname)</li></div>
</ul>
<p><strong style="font-size: 15px; color: #e05f03;">Outros Tipos de Comparação</strong></p>
<div style="text-align: justify;">Além das comparações do tipo “igual” 
utilizadas nos exemplos apresentados até aqui, também são possíveis 
outros tipos de comparação. Para que outros tipos de comparação sejam 
utilizadas existem duas abordagens possíveis. A primeira abordagem 
consiste em colocar anotações nos parâmetros registrando o tipo de 
comparação que se deseja fazer. Veja os exemplos:</div>
<pre>List&lt;Person&gt; getPersonByAge(@Greater Integer age);

List&lt;Person&gt; getPersonByName(@Starts String name);</pre>
<div style="text-align: justify;">Com a abordagem baseada em anotações, 
não é possível ter dois métodos que executam uma consulta baseada nos 
mesmos parâmetros mas com tipos de comparação. Por esse motivo, também é
 suportada a sintaxe onde o tipo de comparação é colocado logo após o 
nome da propriedade. Veja os exemplos:</div>
<pre>public List&lt;Person&gt; getPersonByAgeLesser(Integer age);

public List&lt;Person&gt; getPersonByLastNameNotEquals(String name);

public List&lt;Person&gt; getPersonByNameStartsAndAgeGreater(String name, Integer age);</pre>
<div style="text-align: justify;">As anotações possuem extamente o mesmo
 nome da string que precisa ser adicionada no nome do método. No momento
 os operadores suportados são:<strong> Lesser, Greater, LesserOrEquals, GreaterOrEquals, NotEquals, Contains, Starts, Ends</strong>.</div>
<p>&nbsp;</p>
<p><strong style="font-size: 15px; color: #e05f03;">Ordenação de Consultas</strong></p>
<div style="text-align: justify;">Também é possí­vel compor o nome dos 
métodos de forma que as consultas sejam ordenadas. Para isso é 
necessário no final do nome do método colocar OrderBy seguido pelo nome 
da propriedade. Caso seja necessária a ordenação por dois campos, 
pode-se separar o nome deles com and. Também é possí­vel depois do nome 
da propriedade colcoar Asc ou Desc para definir o sentido da ordenação 
(ascendente ou descendente), sendo ASC o valor default. Veja os 
exemplos:</div>
<pre>public List&lt;Person&gt; getPersonOrderByName();

public List&lt;Person&gt; getPersonByAgeOrderByNameDesc(@Greater Integer age);

public List&lt;Person&gt; getPersonOrderByNameAndLastName();</pre>
<p><strong style="font-size: 15px; color: #e05f03;"><br>
Query Objects</strong></p>
<div style="text-align: justify;">Quando a quantidade de parâmetros de 
uma consulta é muito grande, isso inviabiliza a criação de uma consulta 
definida pelo nome do método. Para esses casos, o Esfinge QueryBuilder 
possibilita que propriedades de uma classe sejam utilizadas como 
parâmetro para a consulta. Essa classe deve ser definida como um Java 
Bean comum. As propriedades devem possuir o mesmo nome da propriedade da
 entidade que será filtrada. Existem três possibilidade para se definir 
os tipos de comparação: anotações no atributo, anotações no método 
getter ou adicionar o tipo de comparação no final do nome da 
propriedade.</div>
<div style="text-align: justify;">Abaixo segue um exemplo de uma classe 
desse tipo. Observe que as propriedade ageGreater e ageLesser 
exemplificam o uso do tipo de comparação no nome da propriedade e as 
propriedades name e lastName exemplificam respectivamente o uso de 
anotações no atributo e no método getter.</div>
<pre>public class ExampleQueryObject {

    private Integer ageGreater;
    private Integer ageLesser;

    @Contains
    private String name;
    private String lastName;

    public Integer getAgeGreater() {
        return ageGreater;
    }
    public void setAgeGreater(Integer ageGreater) {
        this.ageGreater = ageGreater;
    }
    public Integer getAgeLesser() {
        return ageLesser;
    }
    public void setAgeLesser(Integer ageLesser) {
        this.ageLesser = ageLesser;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    @Contains
    public String getLastName() {
        return lastName;
    }
    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

}</pre>
<div style="text-align: justify;">Depois de definida a classe, o método 
da interface deve receber apenas essa classe como parâmetro e anotar o 
parâmetro com a anotação @QueryObject. Além disso não se deve utilizar 
como parte do nome do método o “By” com os respectivos parâmetros, porém
 o OrderBy e termos de domínio (apresentados a seguir) podem ser 
utilizados normalmente.</div>
<p>Abaixo segue um exemplo de um método que utiliza a classe definida acima:</p>
<pre>public List getPerson(@QueryObject ExampleQueryObject obj);</pre>
<div style="text-align: justify;">Note que uma classe que definir um 
query object pode inicializar as variáveis com valores default para os 
parâmetros da consulta, o que não é possível quando parâmetros são 
utilizados.</div>
<p></p></div></div><!-- end div.wp-spoiler -->
<div class="wp-spoiler wpui-light"><h3 class="ui-collapsible-header fade-true slide-true open-false"><span class="ui-icon"></span>Termos de Domínio com Query Builder</h3><div class="ui-collapsible-content"><p></p>
    <hr>
<div>
<div style="text-align: justify;">O Esfinge Query Builder define uma DSL
 que pode ser utilizada para definir nomes de métodos de forma que os 
mesmos sejam utilizados para a geração de consultas. Muitas vezes 
existem termos que fazem sentido dentro do domínio e que precisam ser 
utilizados para compor os nomes do métodos. Esse tutorial ensina a 
incluir termos de domínio para uma interface e usar esses termos nos 
nomes dos métodos.</div>
<p><strong style="font-size: 15px; color: #e05f03;">Definindo Termos de Domínio</strong></p>
<div style="text-align: justify;">Os termos de domínio são definidos 
através de anotações na interface que define os métodos com as 
consultas. Os termos de domínio podem ser utilizados para definir 
conjuntos de entidades que fazem sentido dentro do contexto de negócios 
da aplicação. Esses conjuntos são muitas vezes definidos por restrições 
que são incluídas nas consultas. O termo maior de idade denota, por 
exemplo, pessoas cuja a idade é maior que 18 anos e o termo paulista 
denota pessoas nascidas no estado de São Paulo. A idéia é esses termos 
pdoerem ser definidos e utilizados para compor os nomes dos métodos.</div>
<div style="text-align: justify;">Quando apenas um termo de domínio é 
necessário, a anotação @DomainTerm pode ser utilizada para defini-lo. 
Ela deve configurar o nome do termo de domínio e as condições que devem 
ser obedecidas. O nome do termo de domínio pode ser composto por mais de
 uma palavra. Veja abaixo a definição de um termo de domínio com uma 
condição:</div>
<pre>@DomainTerm(term="major", conditions=@Condition(property="age",comparison=ComparisonType.GREATER_OR_EQUALS,value="18"))
public interface PersonQuery{
//methods ommited
}</pre>
<div style="text-align: justify;">O atributo conditions pode receber uma
 lista de anotações do tipo @Condition. Cada uma delas deve definir uma 
propriedade (que pode acessar propriedades de propriedades, como 
address.city), o tipo de comparação e o valor. O tipo de comparação é o 
único valor que pode ser omitido, possuindo como default a comparação 
EQUALS. Veja abaixo um exemplo que define mais de uma condição:</div>
<pre>@DomainTerm(term="teenager",
conditions={@Condition(property="age",comparison=ComparisonType.GREATER_OR_EQUALS,value="13"),
@Condition(property="age",comparison=ComparisonType.LESSER_OR_EQUALS,value="19")})
public interface PersonQuery{
//methods ommited
}</pre>
<div style="text-align: justify;">Caso mais de um termo de domínio 
precise ser definido para a mesma classe, pode-se usar a anotação 
@DomainTerms, que possui uma lista de termos de domínio. Veja abaixo um 
exemplo que define mais de um termo de domínio na mesma classe:</div>
<pre>@DomainTerms({
@DomainTerm(term="elder", conditions=@Condition(property="age",comparison=ComparisonType.GREATER_OR_EQUALS,value="65")),
@DomainTerm(term="paulista", conditions=@Condition(property="address.state",value="SP"))
})
public interface PersonQuery{
//methods ommited
}</pre>
<p><strong style="font-size: 15px; color: #e05f03;">Usando os Termos de Domínio nos Métodos</strong></p>
<div style="text-align: justify;">Usar os termos de domínio no nome dos 
métodos é bem fácil, bastando incluí-los depois do nome da entidade. 
Nesse caso, a condição associada ao termo de domínio será incorporada na
 consulta. Mais de um termo de domínio pode ser utilizado na mesma 
consulta e eles também podem ser utilizados sem restrição junto com 
parâmetros. Veja abaixo um exemplo completo de uma interface que utiliza
 termos de domínio no nome dos métodos:</div>
<pre>@DomainTerms({
@DomainTerm(term="old guys", conditions=@Condition(property="age",comparison=ComparisonType.GREATER_OR_EQUALS,value="65")),
@DomainTerm(term="paulista", conditions=@Condition(property="address.state",value="SP")),
@DomainTerm(term="teenager",conditions={@Condition(property="age",comparison=ComparisonType.GREATER_OR_EQUALS,value="13"),
@Condition(property="age",comparison=ComparisonType.LESSER_OR_EQUALS,value="19")})
})
public interface PersonQueries{
public List&lt;Person&gt; getPersonTeenager();
public List&lt;Person&gt; getPersonPaulista();
public List&lt;Person&gt; getPersonTeenagerPaulista();
public List&lt;Person&gt; getPersonOldGuys();
public List&lt;Person&gt; getPersonPaulistaByAge(@Greater Integer age);
}</pre>
</div>
<p></p></div></div><!-- end div.wp-spoiler -->
<div class="wp-spoiler wpui-light"><h3 class="ui-collapsible-header fade-true slide-true open-false"><span class="ui-icon"></span>Trabalhando com Parâmetros NULL</h3><div class="ui-collapsible-content"><p></p>
    <hr>
<div style="text-align: justify;">As funcionalidades normais do Esfinge 
QueryBuilder não permitem que parâmetros nulos sejam passados para os 
métodos. O resultado é inesperado dependendo do provider utilizado para o
 JPA. Com a configuração de anotações, é possível definir como um valor 
nulo deve ser interpretado pelo framework: deve realmente ser feita a 
comparação com nulo ou o parâmetro deve ser ignorado.</div>
<p>&nbsp;</p>
<p><strong style="font-size: 15px; color: #e05f03;">Comparando com NULL</strong></p>
<div style="text-align: justify;">Para que seja realizada a comparação 
com NULL quando um valor nulo for passado como parâmetro, basta incluir a
 anotação @CompareToNull. Note que nesse caso, será substituída a 
comparação que seria feita (sendo ela maior, igual, menor e etc…) pela 
cláusula IS NULL na consulta. Observe o uso da anotação nos métodos 
abaixo:</div>
<pre>public List&lt;Person&gt; getPersonByCompany(@CompareToNull String company);

public List&lt;Person&gt; getPersonByNameAndLastName(@Starts String name, @CompareToNull String lastname);</pre>
<div style="text-align: justify;">No método getPersonByCompany(), caso 
seja passado o parâmetro NULL serão buscadas todas as pessoas que não 
possuem uma empresa associada. No segundo exemplo, observe que apenas o 
segundo parâmetro possui a anotação, então será válido passar o valor 
nulo apenas para ele.</div>
<p>&nbsp;</p>
<p><strong style="font-size: 15px; color: #e05f03;">Ignorando Parâmetros que Receberem NULL</strong></p>
<div style="text-align: justify;">Outra opção interessante para se lidar
 valores nulos é ignorar o parâmetro quando o valor nulo é recebido. 
Nesse caso, o parâmetro não será incluído na consulta caso seu valor 
seja nulo. Isso pode ser muito interessante para a criação de consultas 
que permitam vários parâmetros opcionais. Para que isso seja feito, 
basta incluir a anotação @IgnoreWhenNull no parâmetro. Veja o exemplo 
abaixo:</div>
<pre>public List&lt;Person&gt; getPersonByNameStartsAndLastNameStarts(@IgnoreWhenNull String name, @IgnoreWhenNull String lastname);</pre>
<div style="text-align: justify;">O exemplo apresenta uma consulta que 
busca pelo nome e pelo sobrenome começados com o que for passado como 
parâmetro. Como ambos os parâmetros possuem a anotação @IgnoreWhenNull, 
ambos podem ser ignorados. Observe que existem na verdade quatro 
consultas possíveis: não ignorando nenhum aprâmetro, ignorando o 
primeiro parâmetro, ignorando o segundo parâmetro e ignorando os dois 
parâmetros. O uso desse recurso pode permitir a combinação de consultas 
em apenas um método, eliminando a necessidade de criação de vários 
outros</div>
<div style="text-align: justify;">Caso as propriedades sejam valores 
primitivos, para utilizar essa funcionalidade, recomenda-se que sejam 
utilizados as respectivas classes wrapper. Por exemplo, utilize Integer 
no lugar de int. Isso permitirá que sejam passados valores nulos e essa 
funcionalidade possa ser utilizada.</div>
<p>&nbsp;</p>
<p><strong style="font-size: 15px; color: #e05f03;">Lidando com NULL em Query Objects</strong></p>
<div style="text-align: justify;">Tanto a anotação @IgnoreWhenNull 
quanto a @CompareToNull podem ser utilizadas em nas propriedades da 
classe quando são utilizados query objects para as consultas. As 
anotações podem ser colocadas nas propriedades ou nos métodos getter.</div>
<p></p></div></div><!-- end div.wp-spoiler -->
<div class="wp-spoiler wpui-light"><h3 class="ui-collapsible-header fade-true slide-true open-false"><span class="ui-icon"></span>Métodos Customizados</h3><div class="ui-collapsible-content"><p></p>
    <hr>
<div style="text-align: justify;">Quando se cria uma interface no 
QueryBuilder, a invocação dos métodos é direcionada para um proxy 
dinâmico que interpreta o nome e executa a consulta adequada. Dessa 
forma, os métodos da interface não possuem de fato uma implementação. Um
 caso a parte ocorre quando a interface estende a interface Repository, 
onde a invocação dos métodos dessa interface são direcionados para uma 
implementação específica. Essa seção ensina a incluir métodos na 
interface que serão direcionados para uma implementação específica.</div>
<p>&nbsp;</p>
<p><strong style="font-size: 15px; color: #e05f03;">Adicionando um método customizado</strong></p>
<p>O primeiro passo para criar um método customizado é definir uma interface apenas com esse método:</p>
<pre>public interface CustomMethodInterface {
    public void customMethod();
}</pre>
<p>Em seguida, define-se uma classe que implementa essa interface:</p>
<pre>public class CustomMethodImpl implements CustomMethodInterface{
    @Override
    public void customMethod() {
        //faz alguma coisa      
    }
}</pre>
<div style="text-align: justify;">Em seguida é preciso configurar essa 
implementação como a que deve ser utilizada para essa interface. Isso 
pode ser feito criando um arquivo com o nome completo da interface, no 
caso org.esfinge.querybuilder.jpa1.custommethods.CustomMethodInterface, 
no caminho META-INF/services dentro de algum jar do classpath, contendo 
apenas o nome da implementação, no caso 
“org.esfinge.querybuilder.jpa1.custommethods.CustomMethodImpl”.</div>
<div style="text-align: justify;">Depois disso, qualquer interface do 
QueryBuilder que estender essa interface que foi definida irá conter 
seus métodos e consequentemente a implementação definida será executada 
quando eles forem invocados.</div>
<p>&nbsp;</p>
<p><strong style="font-size: 15px; color: #e05f03;">Parametrizando a interface</strong></p>
<div style="text-align: justify;">Da forma como foi apresentado na seção
 anterior, o método possui uma implementação fixa e normalmente será 
adicionado em apenas uma interface. Um recurso poderoso é permitir que a
 implementação receba a classe da entidade que está sendo utilizada na 
interface. Dessa forma, a implementação pode usar recursos de reflexão 
para personalizar a execução dependendo da entidade.</div>
<div style="text-align: justify;">Para que isso seja possível, a 
interface que irá definir o método customizado deve possuir um tipo 
genérico e estender a interface NeedClassConfiguration, conforme o 
exemplo abaixo.</div>
<pre>public interface GenericMethodInterface extends NeedClassConfiguration {
    public E createNewInstance();
}</pre>
<div style="text-align: justify;">A implementação precisará implementar 
um método adicional com a seguinte assinatura “public void 
configureClass(Classc)”. Esse método irá receber a classe que será 
configurada como parâmetro do tipo genérico no momento da implementação 
da interface. Segue abaixo o exemplo da implementação. Note que a 
implementação utiliza a classe para retornar uma nova instância da 
mesma.</div>
<pre>public class GenericMethodImpl implements GenericMethodInterface {

    private Class clazz;

    @Override
    public void configureClass(Class c) {
        clazz = c;
    }

    @Override
    public E createNewInstance() {
        try {
            return clazz.newInstance();
        } catch (Exception e) {
            throw new RuntimeException("Not possible to instantiate "+clazz.getName(),e);
        }
    }

}</pre>
<div style="text-align: justify;">A configuração do arquivo que faz a 
ligação entre interface e configuração é feita mesma forma. Quando a 
interface for implementada, é preciso especificar o tipo genérico que 
será utilizado, para a implementação poder receber a classe. Segue o 
exemplo:</div>
<pre>public interface GenericInterface extends GenericMethodInterface{
   //outros métodos
}</pre>
<p><strong style="font-size: 15px; color: #e05f03;">Recuperando implementações</strong></p>
<div style="text-align: justify;">As implementações configuradas dessa 
forma podem ser recuperadas através do método getServiceImplementation()
 da classe org.esfinge.querybuilder.utils.ServiceLocator . Isso pode ser
 muito útil nas implementações para recuperar os serviços já oferecidos 
pelo framework. Abaixo segue um exemplo de como recuperar a classe que 
provê o EntityManager para o framework.</div>
<pre>EntityManagerProvider emp = ServiceLocator.getServiceImplementation(EntityManagerProvider.class)</pre>
<p><strong style="font-size: 15px; color: #e05f03;">Sobrepondo implementações</strong></p>
<div style="text-align: justify;">Qualquer implementação do framework 
que é recuperada dessa forma pode ser sobreposta por uma outra, desde 
que a mesma possua maior prioridade. Para definir uma nova 
implementação, a classe deve implementar a interface desejada e 
configurar o arquivo que liga a implementação a interface da forma como 
foi apresentada anteriormente. A anotação @ServicePriority deve ser 
utilizada na classe passando como parâmetro um número maior que a 
prioridade do serviço a ser sobreposto (que normalmente é zero pois essa
 é a prioridade default quando a anotação não é configurada).</div>
<div style="text-align: justify;">Um exemplo é a interface Repository, 
que é utilidada para implementar as operações do tipo CRUD. Caso seja 
adequado, pode-se sobrepor a implementação existente, criando-se uma 
específica da aplicação.</div>
<p></p></div></div><!-- end div.wp-spoiler -->
<div class="wp-spoiler wpui-light"><h3 class="ui-collapsible-header fade-true slide-true open-false"><span class="ui-icon"></span>Integrando o Query Builder com Spring</h3><div class="ui-collapsible-content"><p></p>
    <hr>
<div>
<p>Agradecimento a contribuição de Leonardo Machado Moreira que escreveu boa parte e desenvolveu o exemplo desse tutorial.</p>
<div style="text-align: justify;">O Esfinge Query Builder pode ser 
facilmente integrado a outros frameworks. Esse tutorial mostra como ele 
pode ser integrado ao Spring Framework, utilizando o EntityManager 
gerenciado por ele.</div>
<p><strong style="font-size: 15px; color: #e05f03;">Configuração do Spring</strong></p>
<p>Abaixo segue o arquivo que mostra como configurar os beans relativos ao acesso ao banco de dados no Spring.</p>
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:tx="http://www.springframework.org/schema/tx"
xsi:schemaLocation="http://www.springframework.org/schema/beans

http://www.springframework.org/schema/beans/spring-beans-3.0.xsd


http://www.springframework.org/schema/tx

http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"
default-autowire="byName"&gt;

&lt;bean id="dataSource"&gt;
&lt;property name="driverClass"        value="com.mysql.jdbc.Driver"/&gt;

&lt;property name="jdbcUrl"            value="jdbc:mysql://localhost:3306/erh"/&gt;
&lt;property name="user"               value="root"/&gt;
&lt;property name="password"           value="303016"/&gt;
&lt;property name="initialPoolSize"    value="5"/&gt;
&lt;property name="minPoolSize"        value="5"/&gt;

&lt;property name="maxPoolSize"        value="50"/&gt;
&lt;property name="autoCommitOnClose"  value="false"/&gt;
&lt;property name="checkoutTimeout"    value="30000"/&gt;
&lt;property name="maxStatements"      value="50"/&gt;
&lt;/bean&gt;

&lt;bean id="entityManagerFactory"&gt;
&lt;property name="dataSource" ref="dataSource" /&gt;
&lt;property name="persistenceUnitName" value="persistence-unit" /&gt;
&lt;/bean&gt;

&lt;bean id="entityManager"&gt;
&lt;property name="entityManagerFactory" ref="entityManagerFactory"/&gt;
&lt;/bean&gt;

&lt;bean id="transactionManager"&gt;
&lt;property name="entityManagerFactory" ref="entityManagerFactory" /&gt;
&lt;/bean&gt;

&lt;tx:annotation-driven transaction-manager="transactionManager" /&gt;

&lt;bean id="springApplicationContext"/&gt;

&lt;/beans&gt;</pre>
<div style="text-align: justify;">O bean dataSource é responsável por 
efetuar a conexão com o banco de dados, neste caso, um banco MySql. A 
configuração da conexão efetuada é simples, com exceção do pool de 
conexões, que neste caso foi utilizado o c3p0. Este pool de conexões 
específico foi utilizado pois este tutorial não tem ambiente 
determinado, então ao invés de indicar um pool de qualquer container ou 
web-server a utilização do c3po se mostrou mais adequada.</div>
<div style="text-align: justify;">O bean entityManagerFactory é a 
implementação da classe LocalContainerEntityManagerFactoryBean, 
responsável por implementar uma factory de Entity Manager. Foi escolhida
 a classe LocalContainerEntityManagerFactoryBean, pois a mesma permite 
controle absoluto na configuração da forma que os EntityManagers serão 
criados. Atente para a propriedade persistenceUnitName, onde informamos o
 nome da unidade de persistencia que a factory deverá procurar. 
Naturalmente o Spring procurará o arquivo persistence.xml na pasta 
resources/META-INF.</div>
<div style="text-align: justify;">O bean entityManager do arquivo 
database.xml é o mais importante na configuração do Spring e o Esfinge 
Query Builder. Nas configurações de Spring e JPA encontradas na internet
 este bean raramente é declarado de forma explicita no contexto, porém o
 Spring sempre cria este Entity Manager de modo a compartilha-lo por 
todo o contexto. Caso você recupere uma Entity Manager utilizando a 
anotação @PersistenceContext com certeza receberá uma classe do tipo 
SharedEntityManagerBean. Esta classe é apenas mais uma implementação de 
Entity Manager como qualquer outra, com uma única difereça, a mesma é 
Thread-Safe, pois será complartilhada por todo contexto.</div>
<div style="text-align: justify;">Também foi declarado o bean transactionManager apenas para indicar o gerenciador de transações a ser utilizado.</div>
<div style="text-align: justify;">O bean springApplicationContext 
foicriado para facilitar a integração do Spring com o Esfinge Query 
Builder, permitindo que o mesmo recupere o EntityManager do contexto do 
Spring. Abaixo segue a implementação dessa classe que serve para a 
recuperação do contexto do Spring.</div>
<pre>public class SpringApplicationContext implements ApplicationContextAware {

private static ApplicationContext CONTEXT;

@Override
public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
CONTEXT = applicationContext;
}

public static Object getBean(String beanName) {
return CONTEXT.getBean(beanName);
}

public static Object getBean(Class&lt;?&gt;classType) {
return CONTEXT.getBean(classType);
}
}</pre>
<p><strong style="font-size: 15px; color: #e05f03;">Configuração do Query Builder</strong></p>
<div style="text-align: justify;">Neste momento toda a configuração 
necessária para o Spring foi descrita, agora a configuração do Esfinge 
Query Builder será abordad. O arquivo 
resources/META-INF/services/org.esfinge.querybuilder.jpa1.EntityManagerProvider
 será responsável por indicar ao Query Builder a classe onde uma 
implementação de EntityManager será pega, neste caso a classe 
org.esfinge.exemplo.jpaprovider.JPAEntityManagerProvider apresentada 
abaixo:</div>
<pre>public class JPAEntityManagerProvider implements EntityManagerProvider {

@Override
public EntityManager getEntityManager() {
return (EntityManager) SpringApplicationContext.getBean("entityManager");
}

@Override
public EntityManagerFactory getEntityManagerFactory() {
return (EntityManagerFactory) SpringApplicationContext.getBean("entityManagerFactory");
}
}</pre>
<div style="text-align: justify;">Esta classe contém os métodos 
indicados pela classe EntityManagerProvider, do querybuilder, onde o 
retorno de um EntityManager e uma EntityManagerFactory se faz 
necessária. Nesta aplicação as instâncias de EntityManager e a 
EntityManagerFactory foram recuperadas do contexto do Spring utilizando 
uma outra classe a SpringApplicationContext.</div>
<div style="text-align: justify;">Esta é uma forma do próprio Spring 
para a recuperação de beans presentes no contexto do Spring por código 
vindo de fora do contexto. Neste momento que o bean 
springApplicationContext é importante, pois ele permitirá que a classe 
EntityManagerProvider recupere os beans de EntityManager e 
EntityManagerFactory do Spring mesmo sem pertencer a qualquer tipo de 
contexto.</div>
<p>Agora é só criar as instâncias a partir do QueryBuilder baseadas nas suas interfaces!</p>
<div style="text-align: justify;">Atenção: é importante lembrar que 
quando o EntityManager do Spring é usado, o arquivo 
esfinge_querybuilder_jpalocal1_1_X.jar não deve ser incluído no 
classpath!</div>
</div>                
                </div>
            </div>



<div class="wp-spoiler wpui-light">
	<h3 class="ui-collapsible-header fade-true slide-true open-false">
		<span class="ui-icon"></span>Plugin Para Eclipse
	</h3>
	<div class="ui-collapsible-content">
		<p></p>
    	<hr>
		<div style="text-align: justify;">
O Esfinge Query Builder também oferece um plugin para Eclipse que busca 
facilitar ainda mais o desenvolvimento, encontrando erros no uso da DSL 
do framework e apontando-os ao usuário em tempo de compilação que caso 
contrário, apenas seriam encontrados em tempo de execução. O plugin 
busca tirar o máximo de proveito dos recursos de validação do Query 
Builder, uma vez que faz uso do próprio framework para validar a DSL 
empregada nos métodos de consulta. Além disso, o plugin também é 
responsável por refatorar automaticamente qualquer ocorrência dos 
atributos de uma entidade nos métodos de consulta sempre que os getters 
dessa entidade forem refatorados.</div>
			<p>&nbsp;</p>
			<p><strong style="font-size: 15px; color: #e05f03;">Instalação</strong></p>
			<div style="text-align: justify;">
				O plugin pode ser instalado manualmente seguindo os passos abaixo:
				<p>&nbsp;</p>
				<ol>
					<li>Baixe o <a href="https://sourceforge.net/projects/esfinge/files/Esfinge2/QueryBuilder%20Plugin%201.0/">Esfinge Query Builder Plugin</a> (EsfingePlugin_1.0.0.jar)</li>
					<li>Copie o plugin para o diretório <i>plugins</i> dentro da raiz do Eclipse</li>
					<li>Reinicie o Eclipse</li>
				</ol>
		</div>
		<p>&nbsp;</p>
		<p><strong style="font-size: 15px; color: #e05f03;">Uso</strong></p>
		<div style="text-align: justify;">O plugin é ativado automaticamente 
assim que é instalado, mas é possível desabilitar ou habilitar o mesmo 
sempre que necessário clicando com o botão direito do mouse sobre o 
projeto e em seguida escolher a opção <b>Remove Esfinge Builder</b> ou <b>Add Esfinge Builder</b>.</div>
		<p>&nbsp;</p>
		<center>
			<img src="Esfinge%20Query%20Builder_files/querybuilder_plugin_menu.png">
		</center>
		<p>&nbsp;</p>
		<div style="text-align: justify;">Uma vez ativado, o plugin é capaz de
 indicar erros de nomenclatura presentes na assinatura dos métodos de 
consulta bem como nos tipos e números de parâmetros dos mesmos. Os erros
 de nomenclatura ficam sublinhados em vermelho no código, como pode ser 
observado na imagem abaixo:</div>
		<p>&nbsp;</p>
		<center>
			<img src="Esfinge%20Query%20Builder_files/querybuilder_plugin_exemplo.png">
		</center>
		<p>&nbsp;</p>
		<div style="text-align: justify;">Os marcadores são atualizados a cada
 novo evento de construção e, caso a configuração de construção 
automática esteja ativada (como indicado na figura abaixo), a validação é
 feita sempre que um arquivo é salvo.</div>
		<p>&nbsp;</p>
		<center>
			<img src="Esfinge%20Query%20Builder_files/querybuilder_plugin_auto.png">
		</center>
		<p>&nbsp;</p>
		<p><strong style="font-size: 15px; color: #e05f03;">Refatoração</strong></p>
		<div style="text-align: justify;">Sempre que uma entidade ou os 
getters de seus atributos forem renomeados, o plugin também irá renomear
 qualquer ocorrência alusiva a essas entidades ou suas propriedades nos 
métodos de consulta presentes em cada DAO.</div>
		<p>&nbsp;</p>
		<center>
			<img src="Esfinge%20Query%20Builder_files/querybuilder_plugin_refatoracao.gif">
		</center>
		<p>&nbsp;</p>
		<div style="text-align: justify;">É importante lembrar que a 
refatoração de uma atributo não desencadeia a refatoração automática nas
 interfaces, por esse motivo é necessário refatorar os getters das 
entidades para que o plugin realize a refatoração automática dos métodos
 nas interfaces de consulta.</div>
	</div>
</div>


<hr>


<div class="wp-spoiler wpui-light">
    <h3 class="ui-collapsible-header fade-true slide-true open-false">
        <span class="ui-icon"></span>
        Query Builder com MongoDB
    </h3>
</div>

<hr>

<div style="text-align: justify;">
    <p> O MongoDB é um banco de dados NoSQL, opensource, de alta 
performance, escrito em C++ e orientado a documentos, sendo que seus 
documentos seguem o formato JSON. Este módulo tem seu desenvolvimento 
com o apoio do projeto Morphia, pois providencia a tradução de objetos 
Java para o banco.  </p>
    <p> Para utilizá-lo com o Query Builder siga os seguintes passos: </p>
    <p> Primeiramente crie um novo projeto Java e adicione os seguintes JARs nele: </p>
    <ul>
        <li> mongo-2.7.3.jar </li>
        <li> morphia-0.99.1-SNAPSHOT.jar </li>
        <li> QueryBuilder_jar.jar </li>
        <li> QueryBuilder_MongoDB_jar.jar </li> 
        <li> QueryBuilderParser_jar.jar </li>
    </ul>

    <p> Os JARs podem ser encontrados no seguinte link 
https://github.com/rmmariano/jars_for_query_builder_mongodb ou caso 
queira o código-fonte, estão disponíveis em 
https://github.com/EsfingeFramework/querybuilder </p>


	<p> Crie um arquivo com o nome 
"org.esfinge.querybuilder.mongodb.DatastoreProvider" em uma pasta 
META-INF/services no código-fonte do projeto. Neste arquivo coloque 
somente uma linha com o nome da classe que herda da DatastoreProvider. </p>
	<pre>org.esfinge.querybuilder.mongodb.MongoDBDatastoreProvider</pre>
	
	
    <p> Crie uma classe para ser persistida no Java/MongoDB. Utilize a 
anotação @Id para indicar quem é o indicador único do objeto/documento 
(ex.: classe Cliente) </p>

    <center>
        <img src="Esfinge%20Query%20Builder_files/qbm_c_cliente.png">
    </center>


    <p> Caso essa classe contenha referências, crie-as também (ex.: classe Cachorro e Pagamento </p>

    <center>
        <img src="Esfinge%20Query%20Builder_files/qbm_c_cachorro.png">

        <br><br>

        <img src="Esfinge%20Query%20Builder_files/qbm_c_pagamento.png">
    </center>


    <p> Crie uma classe que herde a DatastoreProvider, colocando a 
conexão do MongoDB em seu construtor. Lembrando de utilizar o IP/porta 
do teu banco, que por padrão é 127.0.0.1/27017. Sobreescreva o método 
getDatastore(), criando um Datastore passando a conexão do banco com o 
nome do DB utilizado. Utilize o método getMorphia().map() passando como 
parâmetro quais as classes que devem ser persistidas. A anotação 
@ServicePriority(1) serve para dar prioridade ao serviço, no caso maior 
prioridade (ex.: classe MongoDBDatastoreProvider).</p>

    <center>
        <img src="Esfinge%20Query%20Builder_files/qbm_c_datastore.png">
    </center>

    <p>&nbsp;</p>
    
    <p><strong style="font-size: 15px; color: #e05f03;"> Salvando um objeto </strong></p>

    <p> Crie um objeto da classe que herda da DatastoreProvider e a 
partir dele pegue o Datastore, com este objeto obtido, utilize o método 
save para salvar os objetos no banco. </p>

    <center>
        <img src="Esfinge%20Query%20Builder_files/qbm_crud_save.png">
    </center>

    <p>&nbsp;</p>

    <p><strong style="font-size: 15px; color: #e05f03;"> Consultando dados </strong></p>

    <p> Crie um objeto da classe que herda da DatastoreProvider e a 
partir dele pegue o Datastore, com este objeto obtido, utilize o método 
find para retornar os objetos no banco, converta-o para uma List e 
itere-o. </p>

    <center>
        <img src="Esfinge%20Query%20Builder_files/qbm_crud_read.png">
    </center>



</div>







             <p>&nbsp;</p>
                    <p>&nbsp;</p>
                    <p>&nbsp;</p>

                     <div align="center"><p><strong style="font-size:20px;color:#000000">Apoio</strong></p></div>
                    <div align="center"><a href="http://www.inpe.br/"><img class="alignleft size-full wp-image-192" title="bt_leiamais" src="Esfinge%20Query%20Builder_files/inpe.png" alt="" border="0" height="34" width="123"></a></div>


            <div id="divFooter" style="height:50px;margin-top:40px;padding:30px">
                    <div class="row-fluid">
                    <div align="center"><p><img src="Esfinge%20Query%20Builder_files/logo2.png" alt="" height="104" width="611"></p></div>
                    <div align="center"><p><strong style="font-size: 10px; color: #000000">Todos os direitos reservados</strong></p></div>
                    </div>
                    
                    </div>
                </div>

            <script src="Esfinge%20Query%20Builder_files/jquery.js" type="text/javascript"></script> 
<script src="Esfinge%20Query%20Builder_files/bootstrap.js" type="text/javascript"></script>
<script src="Esfinge%20Query%20Builder_files/default.js" type="text/javascript"></script>

<script src="Esfinge%20Query%20Builder_files/jquery_003.js" type="text/javascript"></script><script type="text/javascript">$('#list_photos').carouFredSel({ responsive: true, width: '100%', scroll: 2, items: {width: 320,visible: {min: 2, max: 6}} });</script><script src="Esfinge%20Query%20Builder_files/camera.js" type="text/javascript"></script>
<script src="Esfinge%20Query%20Builder_files/jquery_002.js" type="text/javascript"></script>
<script type="text/javascript">function startCamera() {$('#camera_wrap').camera({ fx: 'scrollLeft', time: 2000, loader: 'none', playPause: false, navigation: true, height: '35%', pagination: true });}$(function(){startCamera()});</script>



</div></div></body></html>